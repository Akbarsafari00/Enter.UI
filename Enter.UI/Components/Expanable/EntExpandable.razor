@namespace Enter.UI.Components
@using Enter.UI.Interops;
@using Enter.UI.JsService;
@using Enter.UI.Services.Contracts;
@inherits EntBaseComponent

<div 
    @ref="_reference" 
    @attributes="@AdditionalAttributes" 
    @onanimationend="EventUtil.AsNonRenderingEventHandler(OnAnimationEnd)" 
    class="@RootCss" 
    style="@RootStyle" 
    id="@Id">
    @ChildContent
</div>

@code {

    // Private Properties
    private EntExpandableAnimationState? animationState = null;
    private bool? _tempShow = null;
    internal double _height = 0;
    private ElementReference _reference { get; set; }
    // Inject Services
    [Inject]
    internal IEntSharedJsService SharedJsService { get; set; }

    // Style and Css
    private string RootCss => CssClassBuilder
        .AddClass("ent-expandable")
        .AddClass("ent-expandable-closed", animationState == EntExpandableAnimationState.Closed)
        .AddClass("ent-expandable-opened", animationState == EntExpandableAnimationState.Opened)
        .AddClass("ent-expandable-closing", animationState == EntExpandableAnimationState.Closing)
        .AddClass("ent-expandable-opening", animationState == EntExpandableAnimationState.Opening)
        .Build();

    private string RootStyle => StyleBuilder
        .AddStyle("transition: all 0.25s ease-in-out",animationState is EntExpandableAnimationState.Closing or EntExpandableAnimationState.Opening)
        .AddStyle($"height : auto",animationState == EntExpandableAnimationState.Opened)
        .AddStyle($"height : 0px", animationState == EntExpandableAnimationState.Closed)
        .AddStyle($"height : {_height}px",animationState is EntExpandableAnimationState.Closing or EntExpandableAnimationState.Opening)
        .Build();

  
    

    // Parameters
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    [Parameter]
    public bool Expended { get; set; } = true;


    protected override async Task OnInitializedAsync()
    {
        animationState = Expended switch
        {
            true => EntExpandableAnimationState.Opened,
            false => EntExpandableAnimationState.Closed
        };
    }


    public async Task OnAnimationEnd()
    {
        await Task.Delay(200);
        if (animationState == EntExpandableAnimationState.Closing)
        {
           
            animationState = EntExpandableAnimationState.Closed;
        }
        if (animationState == EntExpandableAnimationState.Opening)
        {
            animationState = EntExpandableAnimationState.Opened;
        }
        StateHasChanged();
    }

    protected override async Task OnParametersSetAsync()
    {
        if (_tempShow != Expended && FirstRendered)
        {
            animationState = Expended switch {
                true => EntExpandableAnimationState.Opening,
                false => EntExpandableAnimationState.Closing,
            };
            // await _expandableIntrop.ToogleAsync(Id, Show.Value);
            _tempShow = Expended;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        _height = (await SharedJsService.GetBoundingClientRect(ElementReference)).ScrollHeight;
        await base.OnAfterRenderAsync(firstRender);
    }


    enum EntExpandableAnimationState
    {
        Closed,
        Opened,
        Opening,
        Closing
    }


}