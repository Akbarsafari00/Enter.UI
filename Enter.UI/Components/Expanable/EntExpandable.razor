@namespace Enter.UI.Components
@using Enter.UI.Interops;
@using Enter.UI.Services.Contracts;
@inherits EntBaseComponent

<div @ref="ElementReference" @attributes="@AdditionalAttributes" @onanimationend="EventUtil.AsNonRenderingEventHandler(OnAnimationEnd)" class="@RootCss" style="@RootStyle" id="@Id">
    @ChildContent
</div>

@code {

    enum EntExpandableAnimationState
    {
        Close,
        Open,
        Opening,
        Closing
    }

    private string RootCss => CssClassBuilder
        .AddClass("ent-expandable")
        .AddClass("ent-expandable-close", animationState == EntExpandableAnimationState.Close)
        .AddClass("ent-expandable-open", animationState == EntExpandableAnimationState.Open)
        .AddClass("ent-expandable-closing", animationState == EntExpandableAnimationState.Closing)
        .AddClass("ent-expandable-opening", animationState == EntExpandableAnimationState.Opening)
        .Build();
    
    private string RootStyle => StyleBuilder
    
        .AddStyle($"height : auto",animationState == EntExpandableAnimationState.Open)
        .AddStyle($"height : {_height}px",animationState is EntExpandableAnimationState.Closing or EntExpandableAnimationState.Opening)
        .Build();

    [Inject]
    public IEntJsService JsService { get; set; }

    private ExpandableInterop _expandableIntrop = default;
    private EntExpandableAnimationState animationState = EntExpandableAnimationState.Close;
    public bool? _tempShow = null;
    public double? _height = 0;

    public ElementReference ElementReference { get; set; }
    
    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    [Parameter]
    public bool? Show { get; set; }

    [Parameter]
    public EventCallback<bool> ShowChanged { get; set; }

    protected override async Task OnInitializedAsync()
    {
        _expandableIntrop = new ExpandableInterop(JsService);
        await base.OnInitializedAsync();
    }


    public async Task OnAnimationEnd()
    {
        if (animationState == EntExpandableAnimationState.Closing)
        {
            animationState = EntExpandableAnimationState.Close;
        }
        if (animationState == EntExpandableAnimationState.Opening)
        {
            animationState = EntExpandableAnimationState.Open;
        }
        StateHasChanged();
    }

    protected override async Task OnParametersSetAsync()
    {
        if (_tempShow != Show)
        {
           
            
            animationState = Show switch {
                true => EntExpandableAnimationState.Opening,
                false => EntExpandableAnimationState.Closing,
                };
            // await _expandableIntrop.ToogleAsync(Id, Show.Value);
            _tempShow = Show;
        }
        await base.OnParametersSetAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var boundingClientRect = await JsService.GetBoundingClientRect(ElementReference);
            _height = boundingClientRect.ScrollHeight;
            StateHasChanged();
            await _expandableIntrop.InitializeAsync(Id, Show.Value);
        }

        await base.OnInitializedAsync();
    }


}